import {
  scanForVulnerabilities,
  getVulnerabilities,
  VulnerabilityScanner,
} from "../../src/services/vulnerability-scanner"
import { PackageManagerDetector } from "../../src/utils/package-manager"
import { promises as fs } from "fs"
import { join } from "path"
import { tmpdir } from "os"

// Mock the package manager and logger
jest.mock("../../src/utils/package-manager")
jest.mock("../../src/utils/logger", () => ({
  logger: {
    error: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  },
}))

const mockPackageManager = {
  install: jest.fn(),
  uninstall: jest.fn(),
  checkOutdated: jest.fn(),
  getDependencies: jest.fn(),
  updateDependency: jest.fn(),
  bulkUpdateDependencies: jest.fn(),
  audit: jest.fn(),
  getInstalledVersion: jest.fn(),
}

const mockPackageManagerDetector = PackageManagerDetector as jest.Mocked<
  typeof PackageManagerDetector
>

describe("Vulnerability Scanner Service", () => {
  let testDir: string

  beforeEach(async () => {
    // Create a temporary directory for each test
    testDir = await fs.mkdtemp(join(tmpdir(), "audit-test-"))

    // Reset all mocks
    jest.clearAllMocks()

    // Setup default mock behavior
    mockPackageManagerDetector.detect.mockReturnValue(mockPackageManager)
  })

  afterEach(async () => {
    // Clean up test directory
    try {
      await fs.rm(testDir, { recursive: true, force: true })
    } catch (error) {
      // Ignore cleanup errors
    }
  })

  describe("VulnerabilityScanner class", () => {
    test("should create scanner with default project path", () => {
      const scanner = new VulnerabilityScanner()
      expect(scanner).toBeInstanceOf(VulnerabilityScanner)
      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(
        process.cwd(),
      )
    })

    test("should create scanner with custom project path", () => {
      const customPath = "/custom/path"
      const scanner = new VulnerabilityScanner(customPath)
      expect(scanner).toBeInstanceOf(VulnerabilityScanner)
      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(customPath)
    })

    test("should return empty array when no vulnerabilities found", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: null })

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(mockPackageManager.audit).toHaveBeenCalled()
    })

    test("should return empty array when vulnerabilities object is empty", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: {} })

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
    })

    test("should process vulnerabilities with complete data", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          lodash: {
            severity: "high",
            via: [{ version: "4.17.20" }],
            range: "<4.17.21",
            fixAvailable: { version: "4.17.21" },
            url: "https://security.npm.com/advisories/123",
          },
          express: {
            severity: "moderate",
            via: [{ version: "4.17.1" }],
            range: "<4.18.0",
            fixAvailable: { version: "4.18.2" },
            references: [
              {
                url: "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-123",
              },
            ],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(2)

      // Test lodash vulnerability
      const lodashVuln = result.find((v) => v.name === "lodash")
      expect(lodashVuln).toEqual({
        name: "lodash",
        version: "4.17.20",
        severity: "high",
        vulnerableVersions: "<4.17.21",
        recommendation: "Update to 4.17.21",
        url: "https://security.npm.com/advisories/123",
      })

      // Test express vulnerability
      const expressVuln = result.find((v) => v.name === "express")
      expect(expressVuln).toEqual({
        name: "express",
        version: "4.17.1",
        severity: "moderate",
        vulnerableVersions: "<4.18.0",
        recommendation: "Update to 4.18.2",
        url: "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-123",
      })
    })

    test("should handle vulnerabilities with missing data", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "incomplete-package": {
            severity: "low",
            via: [{}], // Missing version
            // Missing range
            fixAvailable: false,
            // Missing url and references
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "incomplete-package",
        version: "unknown",
        severity: "low",
        vulnerableVersions: "unknown",
        recommendation: "No fix available",
        url: undefined,
      })
    })

    test("should handle vulnerabilities with fix available but no version", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "no-fix-version": {
            severity: "critical",
            via: [{ version: "1.0.0" }],
            range: "<2.0.0",
            fixAvailable: {}, // No version specified
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "no-fix-version",
        version: "1.0.0",
        severity: "critical",
        vulnerableVersions: "<2.0.0",
        recommendation: "Update to latest",
        url: undefined,
      })
    })

    test("should handle audit errors gracefully", async () => {
      const { logger } = require("../../src/utils/logger")
      mockPackageManager.audit.mockRejectedValue(new Error("Audit failed"))

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(logger.error).toHaveBeenCalledWith(
        "Error scanning for vulnerabilities: Audit failed",
      )
    })

    test("should handle network errors gracefully", async () => {
      const { logger } = require("../../src/utils/logger")
      mockPackageManager.audit.mockRejectedValue(new Error("Network timeout"))

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(logger.error).toHaveBeenCalledWith(
        "Error scanning for vulnerabilities: Network timeout",
      )
    })
  })

  describe("Helper functions", () => {
    test("getVulnerabilities should work with current directory", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: {} })

      const result = await getVulnerabilities()

      expect(result).toEqual([])
      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(
        process.cwd(),
      )
    })

    test("scanForVulnerabilities should work with specified path", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: {} })

      const result = await scanForVulnerabilities(testDir)

      expect(result).toEqual([])
      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(testDir)
    })

    test("scanForVulnerabilities should work without path parameter", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: {} })

      const result = await scanForVulnerabilities()

      expect(result).toEqual([])
      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(
        process.cwd(),
      )
    })
  })

  describe("Real world scenarios", () => {
    test("should handle complex vulnerability structure from npm audit", async () => {
      const complexAuditResult = {
        vulnerabilities: {
          "react-scripts": {
            severity: "high",
            via: [
              {
                version: "5.0.1",
                source: 1096781,
                dependency: "react-scripts",
              },
              "webpack-dev-server",
            ],
            range: ">=5.0.0",
            fixAvailable: {
              name: "react-scripts",
              version: "5.0.2",
              isSemVerMajor: false,
            },
            references: [
              {
                url: "https://github.com/advisories/GHSA-example",
              },
            ],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(complexAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "react-scripts",
        version: "5.0.1",
        severity: "high",
        vulnerableVersions: ">=5.0.0",
        recommendation: "Update to 5.0.2",
        url: "https://github.com/advisories/GHSA-example",
      })
    })

    test("should handle empty via array", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "empty-via": {
            severity: "medium",
            via: [], // Empty array
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].version).toBe("unknown")
    })
  })

  describe("Integration tests", () => {
    test("should work with different package manager types", async () => {
      // Test with different mock package managers
      const npmManager = { ...mockPackageManager }
      const yarnManager = { ...mockPackageManager }
      const pnpmManager = { ...mockPackageManager }

      // Test npm
      mockPackageManagerDetector.detect.mockReturnValueOnce(npmManager)
      npmManager.audit.mockResolvedValue({ vulnerabilities: {} })

      let scanner = new VulnerabilityScanner(testDir)
      let result = await scanner.scan()
      expect(result).toEqual([])

      // Test yarn
      mockPackageManagerDetector.detect.mockReturnValueOnce(yarnManager)
      yarnManager.audit.mockResolvedValue({ vulnerabilities: {} })

      scanner = new VulnerabilityScanner(testDir)
      result = await scanner.scan()
      expect(result).toEqual([])

      // Test pnpm
      mockPackageManagerDetector.detect.mockReturnValueOnce(pnpmManager)
      pnpmManager.audit.mockResolvedValue({ vulnerabilities: {} })

      scanner = new VulnerabilityScanner(testDir)
      result = await scanner.scan()
      expect(result).toEqual([])
    })
  })

  describe("Edge cases and error scenarios", () => {
    test("should handle malformed audit result without vulnerabilities property", async () => {
      mockPackageManager.audit.mockResolvedValue({})

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
    })

    test("should handle audit result with null vulnerabilities", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: null })

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
    })

    test("should handle audit result with undefined vulnerabilities", async () => {
      mockPackageManager.audit.mockResolvedValue({
        vulnerabilities: undefined,
      })

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
    })

    test("should handle vulnerabilities with null via property", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "null-via-package": {
            severity: "high",
            via: null,
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "null-via-package",
        version: "unknown",
        severity: "high",
        vulnerableVersions: "*",
        recommendation: "No fix available",
        url: undefined,
      })
    })

    test("should handle vulnerabilities with undefined via property", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "undefined-via-package": {
            severity: "critical",
            // via is undefined
            range: ">=1.0.0",
            fixAvailable: { version: "2.0.0" },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "undefined-via-package",
        version: "unknown",
        severity: "critical",
        vulnerableVersions: ">=1.0.0",
        recommendation: "Update to 2.0.0",
        url: undefined,
      })
    })

    test("should handle vulnerabilities with missing severity", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "no-severity-package": {
            // severity is undefined
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].severity).toBeUndefined()
    })

    test("should handle via array with non-object elements", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "string-via-package": {
            severity: "medium",
            via: ["dependency-name", "another-dependency"],
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].version).toBe("unknown")
    })

    test("should handle large number of vulnerabilities efficiently", async () => {
      const mockAuditResult = {
        vulnerabilities: {},
      }

      // Generate 1000 vulnerabilities
      for (let i = 0; i < 1000; i++) {
        mockAuditResult.vulnerabilities[`package-${i}`] = {
          severity:
            i % 4 === 0
              ? "critical"
              : i % 3 === 0
                ? "high"
                : i % 2 === 0
                  ? "medium"
                  : "low",
          via: [{ version: `1.0.${i}` }],
          range: `<2.0.${i}`,
          fixAvailable: { version: `2.0.${i}` },
        }
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const startTime = Date.now()
      const result = await scanner.scan()
      const endTime = Date.now()

      expect(result).toHaveLength(1000)
      expect(endTime - startTime).toBeLessThan(1000) // Should complete in less than 1 second
    })

    test("should handle timeout errors", async () => {
      const { logger } = require("../../src/utils/logger")
      mockPackageManager.audit.mockRejectedValue(new Error("Command timed out"))

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(logger.error).toHaveBeenCalledWith(
        "Error scanning for vulnerabilities: Command timed out",
      )
    })

    test("should handle permission errors", async () => {
      const { logger } = require("../../src/utils/logger")
      mockPackageManager.audit.mockRejectedValue(
        new Error("EACCES: permission denied"),
      )

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(logger.error).toHaveBeenCalledWith(
        "Error scanning for vulnerabilities: EACCES: permission denied",
      )
    })

    test("should handle corrupted package.json scenarios", async () => {
      const { logger } = require("../../src/utils/logger")
      mockPackageManager.audit.mockRejectedValue(
        new Error("Invalid package.json"),
      )

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toEqual([])
      expect(logger.error).toHaveBeenCalledWith(
        "Error scanning for vulnerabilities: Invalid package.json",
      )
    })
  })

  describe("Complex vulnerability structures", () => {
    test("should handle vulnerabilities with multiple versions in via array", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "multi-version-package": {
            severity: "high",
            via: [
              { version: "1.0.0" },
              { version: "1.1.0" },
              { version: "1.2.0" },
            ],
            range: "<2.0.0",
            fixAvailable: { version: "2.0.0" },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].version).toBe("1.0.0") // Should use first version
    })

    test("should handle vulnerabilities with nested dependency chains", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "nested-dependency": {
            severity: "critical",
            via: [
              {
                source: 1234567,
                dependency: "nested-dependency",
                version: "3.2.1",
                url: "https://npmjs.com/advisories/1234567",
              },
            ],
            range: "<=3.2.1",
            fixAvailable: {
              name: "nested-dependency",
              version: "3.2.2",
              isSemVerMajor: false,
            },
            references: [{ url: "https://github.com/advisories/GHSA-nested" }],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "nested-dependency",
        version: "3.2.1",
        severity: "critical",
        vulnerableVersions: "<=3.2.1",
        recommendation: "Update to 3.2.2",
        url: "https://github.com/advisories/GHSA-nested",
      })
    })

    test("should handle vulnerabilities with multiple reference URLs", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "multi-ref-package": {
            severity: "medium",
            via: [{ version: "2.1.0" }],
            range: "<=2.1.0",
            fixAvailable: { version: "2.1.1" },
            references: [
              {
                url: "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-001",
              },
              { url: "https://github.com/advisories/GHSA-example" },
              { url: "https://npmjs.com/advisories/789" },
            ],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].url).toBe(
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-001",
      ) // Should use first reference
    })

    test("should prioritize vulnerability url over references", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "url-priority-package": {
            severity: "low",
            via: [{ version: "1.5.0" }],
            range: "*",
            fixAvailable: false,
            url: "https://security.npm.com/advisories/456",
            references: [{ url: "https://github.com/advisories/secondary" }],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].url).toBe("https://security.npm.com/advisories/456") // Should prioritize direct url
    })
  })

  describe("Different package manager audit formats", () => {
    test("should handle Yarn audit format variations", async () => {
      const yarnAuditResult = {
        vulnerabilities: {
          "yarn-package": {
            severity: "high",
            via: [
              {
                version: "4.1.0",
                source: "yarn-advisory-123",
              },
            ],
            range: ">=4.0.0 <4.2.0",
            fixAvailable: {
              name: "yarn-package",
              version: "4.2.0",
              via: ["yarn-package"],
            },
            advisory: "https://yarnpkg.com/en/docs/cli/audit",
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(yarnAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "yarn-package",
        version: "4.1.0",
        severity: "high",
        vulnerableVersions: ">=4.0.0 <4.2.0",
        recommendation: "Update to 4.2.0",
        url: undefined,
      })
    })

    test("should handle pnpm audit format with security advisories", async () => {
      const pnpmAuditResult = {
        vulnerabilities: {
          "pnpm-package": {
            severity: "critical",
            via: [
              {
                version: "1.2.3",
                advisory: "PNPM-2024-001",
                cwe: "CWE-79",
              },
            ],
            range: "<=1.2.3",
            fixAvailable: { version: "1.2.4" },
            advisory: {
              id: "PNPM-2024-001",
              url: "https://pnpm.io/security/PNPM-2024-001",
            },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(pnpmAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "pnpm-package",
        version: "1.2.3",
        severity: "critical",
        vulnerableVersions: "<=1.2.3",
        recommendation: "Update to 1.2.4",
        url: undefined,
      })
    })
  })

  describe("Performance and concurrency tests", () => {
    test("should handle concurrent scan requests", async () => {
      mockPackageManager.audit.mockResolvedValue({
        vulnerabilities: {
          "concurrent-package": {
            severity: "medium",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: { version: "2.0.0" },
          },
        },
      })

      const scanner = new VulnerabilityScanner(testDir)

      // Run multiple scans concurrently
      const promises = Array.from({ length: 10 }, () => scanner.scan())
      const results = await Promise.all(promises)

      // All results should be identical
      results.forEach((result) => {
        expect(result).toHaveLength(1)
        expect(result[0].name).toBe("concurrent-package")
      })

      // Audit should have been called 10 times
      expect(mockPackageManager.audit).toHaveBeenCalledTimes(10)
    })

    test("should handle scan with very long package names", async () => {
      const longPackageName = "a".repeat(1000)
      const mockAuditResult = {
        vulnerabilities: {
          [longPackageName]: {
            severity: "low",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].name).toBe(longPackageName)
    })
  })

  describe("Documentation and API contract tests", () => {
    test("should export all required functions and classes", () => {
      const vulnScanner = require("../../src/services/vulnerability-scanner")

      expect(vulnScanner.VulnerabilityScanner).toBeDefined()
      expect(vulnScanner.getVulnerabilities).toBeDefined()
      expect(vulnScanner.scanForVulnerabilities).toBeDefined()

      expect(typeof vulnScanner.VulnerabilityScanner).toBe("function")
      expect(typeof vulnScanner.getVulnerabilities).toBe("function")
      expect(typeof vulnScanner.scanForVulnerabilities).toBe("function")
    })

    test("should maintain consistent API return types", async () => {
      mockPackageManager.audit.mockResolvedValue({
        vulnerabilities: {
          "api-test-package": {
            severity: "high",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: { version: "2.0.0" },
          },
        },
      })

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      // Verify API contract
      expect(Array.isArray(result)).toBe(true)

      if (result.length > 0) {
        const vuln = result[0]
        expect(vuln).toHaveProperty("name")
        expect(vuln).toHaveProperty("version")
        expect(vuln).toHaveProperty("severity")
        expect(vuln).toHaveProperty("vulnerableVersions")
        expect(vuln).toHaveProperty("recommendation")
        expect(vuln).toHaveProperty("url")
      }
    })

    test("should handle real-world npm audit output format", async () => {
      // This is based on actual npm audit output format as of 2024
      const realWorldAuditResult = {
        auditReportVersion: 2,
        vulnerabilities: {
          semver: {
            name: "semver",
            severity: "moderate",
            isDirect: false,
            via: [
              {
                source: 1088684,
                name: "semver",
                dependency: "semver",
                title:
                  "semver vulnerable to Regular Expression Denial of Service",
                url: "https://github.com/advisories/GHSA-c2qf-rxjj-qqgw",
                severity: "moderate",
                cwe: ["CWE-1333"],
                cvss: {
                  score: 5.3,
                  vectorString: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
                },
                range: ">=7.0.0 <7.5.2",
              },
            ],
            effects: ["make-fetch-happen"],
            range: ">=7.0.0 <7.5.2",
            nodes: ["node_modules/semver"],
            fixAvailable: {
              name: "semver",
              version: "7.5.2",
              isSemVerMajor: false,
            },
          },
        },
        metadata: {
          vulnerabilities: {
            info: 0,
            low: 0,
            moderate: 1,
            high: 0,
            critical: 0,
            total: 1,
          },
          dependencies: {
            prod: 1,
            dev: 0,
            optional: 0,
            peer: 0,
            peerOptional: 0,
            total: 1,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(realWorldAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "semver",
        version: "unknown", // No version in via[0]
        severity: "moderate",
        vulnerableVersions: ">=7.0.0 <7.5.2",
        recommendation: "Update to 7.5.2",
        url: undefined,
      })
    })

    test("should provide consistent error messages", async () => {
      const { logger } = require("../../src/utils/logger")
      const errorMessages = [
        "Connection refused",
        "404 Not Found",
        "Invalid JSON response",
        "Timeout exceeded",
      ]

      for (const errorMessage of errorMessages) {
        jest.clearAllMocks()
        mockPackageManager.audit.mockRejectedValue(new Error(errorMessage))

        const scanner = new VulnerabilityScanner(testDir)
        const result = await scanner.scan()

        expect(result).toEqual([])
        expect(logger.error).toHaveBeenCalledWith(
          `Error scanning for vulnerabilities: ${errorMessage}`,
        )
      }
    })
  })

  describe("Type safety and validation tests", () => {
    test("should handle vulnerabilities with unexpected data types", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "type-mismatch-package": {
            severity: 123, // Number instead of string
            via: "not-an-array", // String instead of array
            range: null, // Null instead of string
            fixAvailable: "true", // String instead of object/boolean
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "type-mismatch-package",
        version: "unknown",
        severity: 123,
        vulnerableVersions: "unknown",
        recommendation: "Update to latest",
        url: undefined,
      })
    })

    test("should handle empty strings in vulnerability data", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "empty-strings-package": {
            severity: "",
            via: [{ version: "" }],
            range: "",
            fixAvailable: { version: "" },
            url: "",
            references: [{ url: "" }],
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        name: "empty-strings-package",
        version: "unknown", // Empty string should fallback to "unknown"
        severity: "",
        vulnerableVersions: "unknown", // Empty string should fallback to "unknown"
        recommendation: "Update to latest", // Empty version should fallback to "latest"
        url: "", // Empty URL should be preserved
      })
    })

    test("should validate returned vulnerability structure", async () => {
      const mockAuditResult = {
        vulnerabilities: {
          "validation-package": {
            severity: "high",
            via: [{ version: "1.0.0" }],
            range: "<2.0.0",
            fixAvailable: { version: "2.0.0" },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)

      const vulnerability = result[0]

      // Validate structure
      expect(vulnerability).toHaveProperty("name")
      expect(vulnerability).toHaveProperty("version")
      expect(vulnerability).toHaveProperty("severity")
      expect(vulnerability).toHaveProperty("vulnerableVersions")
      expect(vulnerability).toHaveProperty("recommendation")
      expect(vulnerability).toHaveProperty("url")

      // Validate types
      expect(typeof vulnerability.name).toBe("string")
      expect(typeof vulnerability.version).toBe("string")
      expect(typeof vulnerability.severity).toBe("string")
      expect(typeof vulnerability.vulnerableVersions).toBe("string")
      expect(typeof vulnerability.recommendation).toBe("string")
      expect(
        vulnerability.url === undefined ||
          typeof vulnerability.url === "string",
      ).toBe(true)
    })

    test("should handle circular references in audit data", async () => {
      const circularRef: any = {
        severity: "medium",
        via: [{ version: "1.0.0" }],
        range: "*",
        fixAvailable: false,
      }
      circularRef.self = circularRef // Create circular reference

      const mockAuditResult = {
        vulnerabilities: {
          "circular-ref-package": circularRef,
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].name).toBe("circular-ref-package")
    })
  })

  describe("Boundary value tests", () => {
    test("should handle extremely long version strings", async () => {
      const longVersion = "1.0.0-" + "a".repeat(10000)
      const mockAuditResult = {
        vulnerabilities: {
          "long-version-package": {
            severity: "low",
            via: [{ version: longVersion }],
            range: "*",
            fixAvailable: false,
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].version).toBe(longVersion)
    })

    test("should handle special characters in package names", async () => {
      const specialPackageName =
        "@scoped/package-with-ç‰¹æ®Šå­—ç¬¦-Ã©mojis-ðŸš€-and-symbols!@#$%"
      const mockAuditResult = {
        vulnerabilities: {
          [specialPackageName]: {
            severity: "medium",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: { version: "2.0.0" },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(1)
      expect(result[0].name).toBe(specialPackageName)
    })

    test("should handle zero vulnerabilities efficiently", async () => {
      mockPackageManager.audit.mockResolvedValue({ vulnerabilities: {} })

      const scanner = new VulnerabilityScanner(testDir)
      const startTime = Date.now()
      const result = await scanner.scan()
      const endTime = Date.now()

      expect(result).toEqual([])
      expect(endTime - startTime).toBeLessThan(100) // Should be very fast for empty results
    })
  })

  describe("Error recovery and resilience", () => {
    test("should recover from partial scan failures", async () => {
      // Mock a scenario where processing one vulnerability fails but others succeed
      const mockAuditResult = {
        vulnerabilities: {
          "good-package": {
            severity: "low",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: { version: "2.0.0" },
          },
          "problematic-package": {
            severity: "high",
            via: [{ version: "1.0.0" }],
            range: "*",
            fixAvailable: { version: "2.0.0" },
          },
        },
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      // Should return results for all packages, even if some have issues
      expect(result).toHaveLength(2)
    })

    test("should handle memory-intensive audit results", async () => {
      const mockAuditResult = {
        vulnerabilities: {},
      }

      // Create a large object with deep nesting
      for (let i = 0; i < 100; i++) {
        mockAuditResult.vulnerabilities[`memory-test-${i}`] = {
          severity: "low",
          via: Array.from({ length: 100 }, (_, j) => ({
            version: `1.0.${j}`,
            details: "x".repeat(1000), // Large string
          })),
          range: "*",
          fixAvailable: { version: "2.0.0" },
          references: Array.from({ length: 50 }, (_, k) => ({
            url: `https://example.com/advisory-${i}-${k}`,
            description: "y".repeat(500),
          })),
        }
      }

      mockPackageManager.audit.mockResolvedValue(mockAuditResult)

      const scanner = new VulnerabilityScanner(testDir)
      const result = await scanner.scan()

      expect(result).toHaveLength(100)
      // Verify memory didn't explode (test should complete without timeout)
      expect(result[0].name).toBe("memory-test-0")
    })
  })

  describe("Integration with package manager detection", () => {
    test("should work correctly with package manager detector", () => {
      const customPath = "/custom/test/path"

      // Verify the scanner correctly uses the package manager detector
      const scanner = new VulnerabilityScanner(customPath)

      expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(customPath)
    })

    test("should use current working directory when no path provided", () => {
      const originalCwd = process.cwd()

      try {
        const scanner = new VulnerabilityScanner()
        expect(mockPackageManagerDetector.detect).toHaveBeenCalledWith(
          originalCwd,
        )
      } finally {
        // Ensure we don't change the actual working directory
      }
    })

    test("should handle package manager detection failures gracefully", async () => {
      const { logger } = require("../../src/utils/logger")

      // Mock package manager detector to throw an error
      mockPackageManagerDetector.detect.mockImplementation(() => {
        throw new Error("Package manager detection failed")
      })

      expect(() => {
        new VulnerabilityScanner(testDir)
      }).toThrow("Package manager detection failed")
    })
  })
})
