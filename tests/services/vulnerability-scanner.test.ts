import { scanForVulnerabilities } from "../../src/services/vulnerability-scanner";
import { promises as fs } from "fs";
import { join } from "path";
import { tmpdir } from "os";

describe("Vulnerability Scanner Service", () => {
  let testDir: string;

  beforeEach(async () => {
    // Create a temporary directory for each test
    testDir = await fs.mkdtemp(join(tmpdir(), "audit-test-"));
  });

  afterEach(async () => {
    // Clean up test directory
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  test("should scan for vulnerabilities in project dependencies", async () => {
    // Create a test package.json with dependencies
    const packageJson = {
      name: "test-project",
      version: "1.0.0",
      dependencies: {
        express: "4.17.1",
        lodash: "4.17.20",
      },
    };

    await fs.writeFile(
      join(testDir, "package.json"),
      JSON.stringify(packageJson, null, 2)
    );

    const vulnerabilities = await scanForVulnerabilities(testDir);

    expect(Array.isArray(vulnerabilities)).toBe(true);
    // Note: In real environment, this might return vulnerabilities, but in test env likely empty
  });

  test("should return an empty array for clean project", async () => {
    // Create a test package.json with minimal dependencies
    const packageJson = {
      name: "test-project",
      version: "1.0.0",
      dependencies: {},
    };

    await fs.writeFile(
      join(testDir, "package.json"),
      JSON.stringify(packageJson, null, 2)
    );

    const vulnerabilities = await scanForVulnerabilities(testDir);

    expect(vulnerabilities).toEqual([]);
  });

  test("should handle invalid project path gracefully", async () => {
    const invalidPath = "/nonexistent/path";

    // Should not throw but might return empty results or handle gracefully
    const vulnerabilities = await scanForVulnerabilities(invalidPath);
    expect(Array.isArray(vulnerabilities)).toBe(true);
  });
});
