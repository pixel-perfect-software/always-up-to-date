import { exec } from "child_process";
import { promisify } from "util";
import {
  PackageManagerDetector,
  PackageManagerInterface,
} from "../utils/package-manager";
import { logger } from "../utils/logger";

const execPromise = promisify(exec);

interface Vulnerability {
  name: string;
  version: string;
  severity: string;
  vulnerableVersions: string;
  recommendation: string;
  url?: string;
}

export class VulnerabilityScanner {
  private packageManager: PackageManagerInterface;

  constructor(private projectPath: string = process.cwd()) {
    this.packageManager = PackageManagerDetector.detect(this.projectPath);
  }

  /**
   * Scans the project for vulnerabilities
   * @returns An array of vulnerabilities found
   */
  async scan(): Promise<Vulnerability[]> {
    try {
      const auditResult = await this.packageManager.audit();

      if (!auditResult.vulnerabilities) {
        return [];
      }

      const vulnerabilities: Vulnerability[] = [];

      // Process npm audit format
      for (const [name, info] of Object.entries(auditResult.vulnerabilities)) {
        const vuln = info as any;
        vulnerabilities.push({
          name,
          version: vuln.via[0].version || "unknown",
          severity: vuln.severity,
          vulnerableVersions: vuln.range || "unknown",
          recommendation: vuln.fixAvailable
            ? `Update to ${vuln.fixAvailable.version || "latest"}`
            : "No fix available",
          url: vuln.url || vuln.references?.[0]?.url,
        });
      }

      return vulnerabilities;
    } catch (error) {
      logger.error(
        `Error scanning for vulnerabilities: ${(error as Error).message}`
      );
      return [];
    }
  }
}

/**
 * Helper function to get vulnerabilities in the current project
 */
export async function getVulnerabilities(): Promise<Vulnerability[]> {
  const scanner = new VulnerabilityScanner();
  return scanner.scan();
}
